import logging
import os
import time
from importlib.resources import files
from pathlib import Path
from shutil import rmtree
from typing import Any, Dict, List, Optional, Set

from python_on_whales import docker
from python_on_whales.exceptions import DockerException

import crl.ctf_api as ctf_api
from crl.config import (
    MAGIC_PASSWORD_VALUE,
)
from crl.helpers import (
    deep_update,
    find_free_port,
    get_endpoint_mode,
    get_service_vips,
    get_services,
    quoted,
    random_string,
    read_random_line,
    read_yaml,
    strip_docker_compose_options,
    write_yaml,
)

"""
CRL handles two docker-compose service traits; environment and ports.
environment:
    FLAGA: crl{DYNAMIC}  # This flag will be replaced with a random string, FLAGA is the challenge id
    FLAGB: apabepa      # This flag will not be handled (ie static), FLAGB is the challenge id
ports:
    - "1337:53"             # All ports that is defined in a challenge (port-id) wil be replaced with a dynamic port.
    - "8080:80"             # This port are static and will be ignored by crl.
"""


log = logging.getLogger(__name__)  # pylint: disable=locally-disabled, invalid-name

PYTHON_ON_WHALES_DEBUG = 0

FLAG_LENGTH = 64
MAGIC_FLAG_VALUE = "crl{DYNAMIC}"  # We only handle flags which begins which this prefix


def get_flag_ports(
    service_ports: Set[str], port_to_flagid: Dict[str, str], used_ports: Set[int] = set()
) -> Dict[str, Dict[str, str]]:
    """
    Parses port mappings from service ports.
    Ports are expected to be in the format of:
        - "published_port:target_port"

    Supports TCP and UDP variants.

    Example:
        8080:80/tcp
        8080:80

    Parameters:
        service_ports: Ports defined in service.
        used_ports: Used ports. Defaults to set().

    Returns:
        Parsed port mappings.
    """
    ports = {}
    for port in service_ports:
        (published_port, target_port) = port.split(":", 1)
        # If we have a dynamic port (==there is a port-id)
        if published_port in port_to_flagid:
            id = port_to_flagid[published_port]
            published_port = str(find_free_port(blacklist=used_ports))
        else:
            id = str(published_port)
        used_ports.add(int(published_port))
        ports[id] = {
            "target_port": target_port,
            "published_port": published_port,
        }
    return ports


def find_ports_used_in_worlds(path: Path) -> Set[int]:
    """
    Finds ports used in Docker Compose configurations within a directory and all sub directories.

    Parameters:
        path: The directory to search for Docker Compose configurations.

    Returns:
        A set of used ports.
    """
    used_ports = set()

    # Find all the world configurations within the given directory and its subdirectories
    configs = path.glob("**/docker-compose.yml")

    for config in configs:
        if docker_config := read_yaml(config):
            for service in docker_config.get("services", {}).values():
                # Extract the host ports from the service's ports mapping
                host_ports = service.get("ports", [])
                used_ports.update([int(p.split(":")[0]) for p in host_ports])  # Assumes HOSTPORT:CONTAINERPORT

    # Return the set of used ports
    return used_ports


def autogenerate_passwords(
    world_config: Dict[str, Any],
) -> Dict[str, Any]:
    """
    Update the passwords in the given Docker configuration based on
    the challenges and services provided. (inline and returned)

    Parameters:
        world_config: A dictionary representing the Docker configuration.
    Returns:
        A dictionary containing the updated Docker configuration after updating autogenerated variables.
    """
    passwordlist = Path(str(files("crl.wordlists").joinpath("rockyou.txt")))
    for service in world_config.get("services", {}).values():
        # Update the passwords if it is found in the service environment
        for e, v in service.get("environment", {}).items():
            if isinstance(v, str) and v.startswith(MAGIC_PASSWORD_VALUE):
                service["environment"][e] = quoted(read_random_line(passwordlist))

    return world_config


def update_flags_and_ports(
    docker_config: Dict[str, Any], event: str, used_ports: Set[int], username: str, external_url: str
) -> Dict[str, Any]:
    """
    Update the flags and ports in the given Docker configuration based on the challenges and services provided.

    Parameters:
        docker_config: A dictionary representing the Docker configuration.
        used_ports: A set of integers representing the ports that are already in use.
        username: A string representing the username.
        external_url: A string representing the url or ip to listen to  address.

    Returns:
        A dictionary containing the updated Docker configuration after updating flags and ports.
    """
    if not ("x-ctfd" in docker_config and "challenges" in docker_config["x-ctfd"] and "services" in docker_config):
        return docker_config

    # Loop over all the challenges and apply the modifications on the services they belong to
    for subchallenges in docker_config["x-ctfd"]["challenges"].values():
        for flagid, challenge in subchallenges.items():
            # Get the services that belong to the challenge
            services = [
                docker_config["services"][service_name]
                for service_name in challenge.get("services", [])
                if service_name in docker_config["services"]
            ]

            # If we have no ports in any of the services == cyber range
            # we delete the connection info field as it will not be used in this case
            if not any("ports" in s for s in services):
                challenge.pop("connection-info", None)

            portid = str(challenge.pop("port-id", ""))

            for service in services:
                ports = service.get("ports")
                # Update the ports and connection-info if we have any ports and there is a port-id
                if portid and ports:
                    flag_ports = get_flag_ports(ports, {portid: flagid}, used_ports)
                    if "connection-info" in challenge and flagid in flag_ports:
                        con_format = challenge["connection-info"]
                        published_port = flag_ports[flagid]["published_port"]
                        challenge["connection-info"] = quoted(con_format.format(HOST=external_url, PORT=published_port))

                    # Repopulate the ports with the newly generated ports
                    service["ports"] = []
                    for port in flag_ports.values():
                        service["ports"].append(quoted(f"{int(port['published_port'])}:{port['target_port']}"))

                # Update the flag if it is found in the service environment
                if "environment" in service:
                    if v := service["environment"].get(flagid):
                        if isinstance(v, str) and v.startswith(MAGIC_FLAG_VALUE):
                            flag_format = docker_config["x-ctfd"].get("flag-format", "crl{FLAG-%user%-%hash%}")
                            safe_name = "".join(challenge["name"].replace("#", "").split())
                            flag = quoted(
                                make_flag(
                                    flag_format,
                                    max_length=FLAG_LENGTH,
                                    event=event,
                                    user=username,
                                    flag=flagid,
                                    name=safe_name,
                                )
                            )
                        else:
                            flag = quoted(v)
                        challenge["flag"] = flag
                        service["environment"][flagid] = flag

    return docker_config


def make_flag(flag_format: str, max_length: int, event: str, user: str, flag: str, name: str) -> str:
    """
    Generate a flag based on supplied flag format string where certain placeholders will get replaced.
    Supported placeholders to be used in flag_format:
        - %user% : Username.
        - %event% : Name of the event.
        - %flag% : Name of the flag.
        - %name% : Name of the challenge.
        - %hash% : Generates a hash with length up to max_length.
        - %hash8% : Generates a hash with length of 8.
        - %hash16% : Generates a hash with length of 16.
        - %hash32% : Generates a hash with length of 32.

    Parameters:
        flag_format: Flag format specification, eg. "crl{flag-%user%-%hash%}".
        max_length: The maximum length of the flag that a generated hash will respect.
        event:  The name of the event.
        user: The name of the user.
        flag: The name of flag from the challenge.

    Returns:
        The generated flag.
    """
    new_flag = flag_format
    new_flag = new_flag.replace("%user%", user)
    new_flag = new_flag.replace("%event%", event)
    new_flag = new_flag.replace("%flag%", flag)
    new_flag = new_flag.replace("%name%", name)

    # replace placeholders for fixed sized hashes.
    hashes_in_format = [h for h in ["%hash8%", "%hash16%", "%hash32%"] if h in new_flag]
    for hsh in hashes_in_format:
        if hsh == "%hash8%":
            size = 8
        elif hsh == "%hash16%":
            size = 16
        elif hsh == "%hash32%":
            size = 32
        else:
            size = 0
        hash = random_string(size)
        new_flag = new_flag.replace(hsh, hash, 1)

    # replace placeholder for dynamic sized hashes.
    while (num_hashes := new_flag.count("%hash%")) > 0:
        len_hash = int((max_length - len(new_flag.replace("%hash%", ""))) / num_hashes)
        hash = random_string(len_hash)
        new_flag = new_flag.replace("%hash%", hash, 1)

    log.debug(f"Flag: {flag_format=} {new_flag=} {event=} {user=} {flag=} length={len(new_flag)}")
    return new_flag


def get_includes(docker_config_base: Dict[str, Any], config_dir: Path) -> Dict[str, Any]:
    """
    Generate the final Docker configuration based on the base configuration and included files.

    Parameters:
        docker_config_base: The base Docker configuration dictionary.
        config_dir: The directory containing the configuration files.

    Returns:
        The final Docker configuration after merging the base and included configurations.
    """
    docker_config: Dict[str, Any] = {
        "x-ctfd": {
            "challenges": {},
        },
        "networks": {},
        "services": {},
    }

    # Loop over all the services and apply the modifications on the services they belong to
    for service in list(docker_config_base["services"]):
        base_service = docker_config_base["services"][service]
        base_service.setdefault("deploy", {}).update(
            {"replicas": 1}
        )  # we always want all services to run with only one replica

        if service == "wireguard":
            base_service["include"] = str(files("crl.services").joinpath("wireguard.yml"))

        # no include so we do nothing but set the hostname and reduce number of ipadresses
        # (not doable if ports are exposed)
        if "include" not in base_service:
            base_service["hostname"] = base_service.get("hostname", service)
            if not base_service.get("ports"):
                base_service["deploy"].update(
                    {"endpoint_mode": "dnsrr"}
                )  # line 245 ensure we always have a deploy section
            continue

        # Remove original service as we will manually copy all fields
        del docker_config_base["services"][service]

        # Read the included file
        include_file = base_service["include"]
        include_path = Path(include_file) if Path(include_file).is_absolute() else config_dir / include_file
        include = read_yaml(include_path)
        if not include:  # Could not read the file so I give up TODO: print error
            log.error(f"Failed to open {include_path}, ignoring {service}")
            del docker_config_base["services"][service]
            continue

        include = normalize_networks(include)
        include = normalize_environment(include)

        iservices = include.get("services", {})
        ichallenges = include.get("x-challenges", {})

        # If we have any "attachments" in the included file update the paths to the absolute path
        if ichallenges:
            for ichallenge in ichallenges.values():
                if "attachments" in ichallenge:
                    paths = []
                    for rp in ichallenge["attachments"]:
                        paths.append(str(include_path.resolve().parent / rp))
                    ichallenge["attachments"] = paths
            docker_config["x-ctfd"]["challenges"][service] = ichallenges

        # Loop over all the included services
        for iname, iservice in iservices.items():
            service_name = f"{service}_{iname}" if len(iservices) > 1 else service
            # If we have any challenges in the included service
            # Add a field services so we keep the information of which services "belong" to which challenge
            if ichallenges:
                # We can have multiple flags in each include challenge
                for challenge in ichallenges.values():
                    challenge.setdefault("services", []).append(service_name)

            ports = iservice.get("ports")  # Save the port information
            iservice = deep_update(iservice, base_service)  # Merge the new service with the blueprint service

            # if we do not have any ports (after the update from the blueprint/base_service) we assume we are in a
            # cyber range therefore we set endpoint_mode: dnsrr to reduce the number of ipadresses used
            if not iservice.get("ports"):
                # The merge with the base_service ensure we always have a deploy section
                iservice["deploy"].update({"endpoint_mode": "dnsrr"})
            # Update the network settings of the config and the service networks
            if len(iservices) > 1:
                # Internal network used for services within the challenge
                internal_net = f"{service}_internal"
                docker_config["networks"].update({internal_net: {"internal": True}})

                # If the service do not expose any ports we assume that it is a "internal" service
                # So we set it on a private network (this is also used in a cyber range setting)
                if not ports:
                    iservice["networks"] = {}
                    iservice["networks"][internal_net] = {"aliases": [iservice.get("hostname", iname)]}
                else:
                    # This is a public service, so it will be both on the challenge internal network
                    # and on the network defined in the blueprint if range or publish ports if jeoprdy style
                    for net_name in list(iservice.get("networks", {})):
                        iservice["networks"][net_name] = {"aliases": [service_name]}
                    iservice.setdefault("networks", {}).update(
                        {internal_net: {"aliases": [iservice.get("hostname", iname)]}}
                    )
            else:
                # We only have one service in the challenge so we create no internal network
                for net_name in list(iservice.get("networks", {})):
                    iservice["networks"][net_name] = {"aliases": [service_name]}

            iservice["hostname"] = service_name
            docker_config["services"][service_name] = iservice

    # If the base service is empty we remove it
    # deepupdate empties the field if it is empty in any of the files
    if not docker_config_base["services"]:
        del docker_config_base["services"]
    deep_update(docker_config, docker_config_base)
    return docker_config


def normalize_environment(docker_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Normalize the environment variables in the given Docker configuration dictionary to always use a dict.

    Parameters:
        docker_config: A dictionary containing Docker configuration data.

    Returns:
        A dictionary with normalized environment variables.
    """
    for service in docker_config.get("services", {}).values():
        env = service.get("environment")
        dict_env = {}
        if isinstance(env, dict):
            dict_env = env
        elif isinstance(env, list):
            for item in env:
                k, v = item.split("=", 1)
                dict_env[k] = v
        elif isinstance(env, str):
            k, v = env.split("=", 1)
            dict_env[k] = v
        if dict_env:
            service["environment"] = dict_env
    return docker_config


def normalize_networks(docker_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Normalizes the networks in the given Docker configuration dictionary to always use a dict

    Parameters:
        docker_config: The Docker configuration dictionary.

    Returns:
        The normalized Docker configuration dictionary.
    """
    if isinstance(docker_config.get("networks"), list):
        docker_config["networks"] = {k: None for k in list(docker_config["networks"])}
    for service in docker_config.get("services", {}).values():
        if isinstance(service.get("networks"), list):
            service["networks"] = {k: None for k in list(service["networks"])}
    return docker_config


def post_challenges(ctf: Dict[str, Any]) -> None:
    """
    Post challenges to a CTF platform using the "challenges" in the given "x-ctfd" of a compose file.

    Parameters:
        ctf: A dictionary containing Docker configuration details.

    Returns:
        None
    """
    for flag in ctf.get("challenges", {}).values():
        for challenge in flag.values():
            new_and_ok_challenge = ctf_api.post_challenge(
                url=ctf["ctf-url"],
                token=ctf["ctf-token"],
                challenge=challenge["name"],
                category=challenge.get("category", ""),
                description=challenge.get("description", ""),
                score=challenge.get("score", None),
                conn_info=challenge.get("connection-info", ""),
            )
            if new_and_ok_challenge:
                # We only try to post file if challange is new so to not create duplicates
                for attachment_path in challenge.get("attachments", []):
                    ctf_api.post_file(
                        url=ctf["ctf-url"],
                        token=ctf["ctf-token"],
                        challenge=challenge["name"],
                        fname=attachment_path,
                    )

                # We only try to post hints if challange is new so to not create duplicates
                hints = challenge.get("hints", {})
                post_hints(ctf["ctf-url"], ctf["ctf-token"], challenge["name"], hints)

            ctf_api.post_flag(
                url=ctf["ctf-url"], token=ctf["ctf-token"], challenge=challenge["name"], flag=challenge["flag"]
            )


def post_hints(url: str, token: str, challenge_name: str, hints: Dict[str, Any]) -> None:
    """
    Post hints for a challenge to a CTF platform defined under "x-ctfd" of docker compose.

    Parameters:
        url: The ctfd url.
        token: The ctfd authentication token.
        challenge_name: The challenge name.
        hints: A dictionary containing hints configuration details.

    Returns:
        None
    """
    posted_hint_ids: Dict[str, int] = {}
    hints_list = list(hints.keys())
    hints_try_again = []
    while hints_list:
        num_starting_hints = len(hints_list)
        for curr_hint in hints_list:
            # Get list of required hints.
            curr_hint_requires = hints[curr_hint].get("requires", [])
            if not isinstance(curr_hint_requires, list):
                curr_hint_requires = [curr_hint_requires]
            log.debug(f"Requires: {curr_hint=} {curr_hint_requires=}")

            # Check if we have posted required hints before.
            curr_hint_requires_ids: List[int] = []
            for hint_require_name in curr_hint_requires:
                hint_require_id = posted_hint_ids.get(hint_require_name)
                if hint_require_id is not None:
                    curr_hint_requires_ids.append(hint_require_id)
                else:
                    log.debug("HINT dependency not added yet.")
                    break

            # Post hint if all required hints were found.
            if len(curr_hint_requires_ids) != len(curr_hint_requires):
                hints_try_again.append(curr_hint)
                log.debug(f"Try again with {curr_hint}")
            else:
                hint_id = ctf_api.post_hint(
                    url=url,
                    token=token,
                    challenge=challenge_name,
                    content=hints[curr_hint].get("content"),
                    cost=hints[curr_hint].get("cost"),
                    prereqs=curr_hint_requires_ids,
                )
                if hint_id is not None:
                    posted_hint_ids[curr_hint] = hint_id

        if hints_try_again:
            if num_starting_hints == len(hints_try_again):
                # Could not resolve any of the required hints, so that means loop!
                log.error(f"Could not resolve required hints {hints_try_again}")
                break
            else:
                log.debug(f"Try posting {hints_try_again=}")
                hints_list = hints_try_again
                hints_try_again = []
        else:
            break


def create(
    event: str,
    blueprint: Path,
    username: str,
    world: Path,
    config_dir: Path,
    world_basepath: Path,
    flag_format_override: Optional[str],
    external_url: str,
    ctf_url: Optional[str],
    ctf_token: Optional[str],
) -> None:
    """
    Creates a Docker stack aka world based on a blueprint.

    Parameters:
        blueprint: Path to the Docker Compose blueprint.
        username: Username.
        world: Path to the world.
        world_basepath: Base path of the world.
        flag_format_override: Will override the blueprint format with one from the event.
        config_dir: The base path for all config files (blueprints/challenges etc).
        external_url: What is my external url/ip.
        ctf_url: URL of CTFd.
        ctf_token: Token for CTFd.

    Returns:
        None
    """
    docker_file = Path(world) / "docker-compose.yml"

    if docker_file.exists():
        log.info(f"{docker_file.name=} already exist")
        return

    # Read template
    docker_config_base = read_yaml(Path(blueprint))
    if not docker_config_base:
        log.info(f"{blueprint=} does not exist")
        return

    # If a flag_format was specified in the event override the blueprint format here (if any)
    if flag_format_override:
        docker_config_base.setdefault("x-ctfd", {})["flag-format"] = flag_format_override

    # Find ports in other worlds
    used_ports = find_ports_used_in_worlds(path=world_basepath)

    # Normalize
    docker_config_base = normalize_networks(docker_config_base)
    docker_config_base = normalize_environment(docker_config_base)
    # Get all included files
    docker_config = get_includes(docker_config_base, config_dir)
    # Strip options not supported in docker
    docker_config = strip_docker_compose_options(docker_config)
    # Generate random flags and set unsused ports and update x-ctfd challenges
    docker_config = update_flags_and_ports(docker_config, event, used_ports, username, external_url)
    docker_config = autogenerate_passwords(docker_config)

    docker_config["x-ctfd"]["blueprint"] = str(blueprint.resolve())
    docker_config["x-ctfd"]["external-url"] = external_url
    if ctf_url:
        docker_config["x-ctfd"]["ctf-url"] = ctf_url
    if ctf_token:
        docker_config["x-ctfd"]["ctf-token"] = ctf_token

    if vpn := docker_config["services"].get("wireguard"):
        WGPORT = find_free_port(blacklist=used_ports)
        WGURL = external_url  # maybe remove as optional
        wg_peer_path = Path(world) / "peer"
        wg_server_path = Path(world) / "server"
        wg_peer_path.mkdir(parents=True, exist_ok=True)
        wg_server_path.mkdir(parents=True, exist_ok=True)
        vpn["ports"] = [quoted(f"{WGPORT}:51820/udp")]
        vpn["volumes"] = [
            f"{wg_peer_path.absolute()}:/config/peer_{username}",
            f"{wg_server_path.absolute()}:/config/server",
        ]
        # If the image env is set and we want it to be overidden ie it start with the magic bash string
        if os.getenv("WG_IMAGE") and vpn.get("image", "${WG_IMAGE:").startswith("${WG_IMAGE:"):
            vpn["image"] = os.getenv("WG_IMAGE")
        vpn_env = vpn["environment"]
        vpn_env["SERVERURL"] = WGURL
        vpn_env["SERVERPORT"] = quoted(WGPORT)
        vpn_env["PEERS"] = username
        vpn_env["PUID"] = quoted(os.getuid())
        vpn_env["PGID"] = quoted(os.getgid())

    if ctf_url and ctf_token and (ctf := docker_config.get("x-ctfd")):
        post_challenges(ctf)

    # Save new config
    world.mkdir(parents=True, exist_ok=True)
    write_yaml(file=docker_file, config=docker_config)


def start(world: Path, world_name: str) -> bool:
    """
    Starts a Docker stack (ie services configured in a docker-compose).

    Parameters:
        world: Path to the world.
        world_name: Name of the world.

    Returns:
        If the stack was successfully deployed.
    """
    # Path to the docker-compose file
    docker_file = world / "docker-compose.yml"

    # Check if the docker-compose file exists
    if read_yaml(docker_file):
        # Deploy the stack with pruning of unused resources and using the docker-compose file
        # See https://gabrieldemarmiesse.github.io/python-on-whales/sub-commands/stack/
        # for more information about the parameters.
        docker.stack.deploy(world_name, prune=True, with_registry_auth=True, compose_files=docker_file)
        return True
    return False


def stop(world: Path, world_name: str) -> bool:
    """
    Stops a Docker stack (ie services configured in a docker-compose).

    Parameters:
        world: Path to the world.
        world_name: Name of the world.

    Returns:
        If the world was successfully stopped.
    """
    # Path to the docker-compose file
    docker_file = world / "docker-compose.yml"

    # Check if the docker-compose file exists
    if read_yaml(docker_file):
        # Remove the stack with the given name, which will stop all services configured in the docker-compose file
        # Hacking in the detach flag here as python-on-whales do not have support for this flag yet
        try:
            docker.stack.remove(world_name)
        except DockerException:
            return False

        # Since we now use the detach Flag the follwoing might be dead code.
        try:
            ps = docker.service.list(filters={"name": world_name})
            ns = docker.network.list(filters={"name": world_name})
            try_counter = 0
            while ps or ns:
                log.debug(f"Stopping {try_counter=}...")
                if try_counter >= 30:
                    return False
                time.sleep(1)
                try:
                    ps = docker.service.list(filters={"name": world_name})
                    ns = docker.network.list(filters={"name": world_name})
                except DockerException:
                    pass
                try_counter += 1
        except DockerException:
            pass
    return True


def inspect(world: Path, world_name: str, netinfo: bool = True) -> Dict[str, Any]:
    """
    Inspects a Docker stack (services configured in a docker-compose).

    Parameters:
        world: Path to the world.
        world_name: Name of the world.

    Returns:
        Inspection results.
    """
    # Path to the docker-compose file
    docker_file = world / "docker-compose.yml"

    # Initialize an empty dictionary to store service inspection results
    services = {}
    running_services = get_services(world_name, inspect_service=netinfo)

    # If the docker-compose file exists, inspect the services
    if docker_config := read_yaml(docker_file):
        # Iterate over each service defined in the docker-compose file
        for name, s in docker_config["services"].items():
            # Get the hostname of the service
            hostname = s["hostname"]

            # Add the service configuration to the dictionary
            services[hostname] = s

            # Add the configured service name to the dictionary
            services[hostname]["configured_service_name"] = name

            services[hostname]["networks"] = {name: "" for name in s.get("networks", {}).keys()}
            # Add the flags to the dictionary
            services[hostname]["flags"] = []
            if "x-ctfd" in docker_config and "challenges" in docker_config["x-ctfd"]:
                mchallenges = docker_config["x-ctfd"]["challenges"]
                for challenges in mchallenges.values():
                    for id, challenge in challenges.items():
                        if name in challenge.get("services", []):
                            if "environment" in s and s["environment"].get(id):
                                services[hostname]["flags"].append(challenge["flag"])

            if hostname in running_services:
                services[hostname]["ID"] = running_services[hostname]["ID"]
                services[hostname]["ServiceID"] = running_services[hostname].get("ServiceID", "")
                services[hostname]["up"] = running_services[hostname]["up"]
                services[hostname]["networks"] = running_services[hostname].get("nets", services[hostname]["networks"])

                if netinfo and get_endpoint_mode(services[hostname]) == "vip":
                    # Put this behind a conditional as it is somewhat expensive
                    services[hostname]["vips"] = get_service_vips(running_services[hostname]["ServiceID"])
            else:
                services[hostname]["up"] = False

    return services


def delete(world: Path, world_name: str) -> bool:
    """
    Deletes a Docker stack (ie services configured in a docker-compose).
    This function stops the stack and cleans up the configuration files.

    Parameters:
        world: Path to the world.
        world_name: Name of the world.

    Returns:
        If the world was successfully deleted.
    """
    docker_file = world / "docker-compose.yml"
    docker_config = read_yaml(docker_file)

    # If the file exists, stop the stack and clean up the configuration files
    if docker_config:
        stop(world=world, world_name=world_name)

        # Get the CTFd configuration
        if ctf := docker_config.get("x-ctfd"):
            # Delete the flags in CTFd
            for flag in ctf.get("challenges", {}).values():
                for challenge in flag.values():
                    ctf_api.delete_flag(
                        url=ctf["url"], token=ctf["token"], flag=challenge["flag"], challenge=challenge["name"]
                    )

        # Print the path of the world being removed
        log.info(f"Removing {world}")

        # If the world is a directory, remove it
        if world.is_dir():
            rmtree(world)
    return True
